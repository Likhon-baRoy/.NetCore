<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Notes</title>

        <style>
            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }
            body {
                font-family: var(--font-stack-text);
                font-weight: 400;
                line-height: 1.4;
                font-size: 1.6rem;
                color: #2d2f31;
            }
            .container {
                position: relative;
                height: 100%;
                overflow-y: auto;
            }
            .content {
                padding: 3.2rem 4.8rem;
                word-break: break-word;
                max-width: 69.6rem;
                margin: 0 auto;
            }
            .heading {
                margin-bottom: 24px;
                font-family: -apple-system, BlinkMacSystemFont, Roboto, "Segoe UI", Helvetica, Arial, sans-serif,
                    "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
                font-weight: 700;
                line-height: 1.2;
                letter-spacing: 0;
                font-size: 32px;
                max-width: 36em;
            }
            .article-asset-container {
                padding: 2.4rem;
            }
            .article-asset-container p {
                font-size: 19px;
            }
            code {
                background-color: #fff;
                border: 1px solid #d1d7dc;
                color: #b4690e;
                font-size: 80%;
                padding: 0.2rem 0.4rem;
                font-family: sfmono-regular, Consolas, liberation mono, Menlo, Courier, monospace;
            }
            p {
                font-weight: 400;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="content">
                <div class="heading">Notes</div>
                <div class="article-asset-container"><h4>Routing</h4><p>At its heart, routing is the mechanism that ASP.NET Core uses to match incoming HTTP requests to specific endpoints (e.g., controller actions, Razor Pages, or minimal API handlers) within your application. This allows you to define clean and meaningful URLs that clearly indicate the resources or actions being requested.</p><p><br></p><p><strong>How Routing Works in ASP.NET Core</strong></p><ol><li><p><strong>Endpoint Registration:</strong> You define endpoints (routes) within your application, specifying:</p><ul><li><p>The URL pattern (e.g., <code>/products</code>, <code>/api/orders/{id}</code>).</p></li><li><p>The HTTP method(s) the endpoint handles (GET, POST, etc.).</p></li><li><p>The code to execute when the endpoint is matched (<code>RequestDelegate</code>).</p></li></ul><p><br></p></li><li><p><strong>Request Matching (Middleware):</strong></p><ul><li><p>The <code>UseRouting</code> middleware component is added to the pipeline.</p></li><li><p>When a request arrives, <code>UseRouting</code> analyzes the incoming URL and HTTP method.</p></li><li><p>It compares the URL against your registered endpoints to find the best match.</p><p><br></p></li></ul></li><li><p><strong>Endpoint Execution (Middleware):</strong></p><ul><li><p>The <code>UseEndpoints</code> middleware component is added to the pipeline, following <code>UseRouting</code>.</p></li><li><p>If <code>UseRouting</code> found a matching endpoint, <code>UseEndpoints</code> executes the code (the <code>RequestDelegate</code>) associated with that endpoint.</p></li></ul></li></ol><p><br></p><h4>UseRouting vs. UseEndpoints</h4><ul><li><p><code><strong>UseRouting</strong></code><strong>:</strong></p><ul><li><p>It's responsible for <strong>route matching</strong> - finding the right endpoint for a given request.</p></li><li><p>It adds route data to the <code>HttpContext</code>, which subsequent middleware can use to make decisions.</p></li><li><p>It <strong>must</strong> come before <code>UseEndpoints</code>.</p></li></ul></li><li><p><code><strong>UseEndpoints</strong></code><strong>:</strong></p><ul><li><p>It's responsible for <strong>endpoint execution</strong> - invoking the code (the delegate) associated with the matched endpoint.</p></li><li><p>It also lets you configure the endpoints (e.g., define policies, filters) using lambda expressions.</p></li></ul></li></ul><p><br></p><p><br></p><h4>Map* Methods: Creating Endpoints</h4><p>ASP.NET Core provides a family of <code>Map*</code> extension methods on the <code>IEndpointRouteBuilder</code> interface that simplify endpoint creation:</p><ul><li><p><code>MapGet</code>: Creates an endpoint that only handles GET requests.</p></li><li><p><code>MapPost</code>: Creates an endpoint that only handles POST requests.</p></li><li><p><code>MapPut</code>, <code>MapDelete</code>: Create endpoints for PUT and DELETE requests, respectively.</p></li><li><p><code>MapMethods</code>: Creates an endpoint that handles multiple HTTP methods.</p></li><li><p><code>MapControllerRoute</code>, <code>MapAreaControllerRoute</code>: Used for configuring MVC/Razor Pages controllers.</p></li><li><p><code>MapFallbackToFile</code>: Used to specify a default file to serve when no other endpoint matches.</p></li></ul><p><br></p><p><strong>Code: Detailed Explanation</strong></p><pre class="prettyprint linenums">//enable routing
app.UseRouting();

//creating endpoints
app.UseEndpoints(endpoints =&gt;
{
    //add your endpoints here
    endpoints.MapGet("map1", async (context) =&gt; {
       await context.Response.WriteAsync("In Map 1");
    });

    endpoints.MapPost("map2", async (context) =&gt; {
       await context.Response.WriteAsync("In Map 2");
    });
});

app.Run(async context =&gt; {
    await context.Response.WriteAsync($"Request received at {context.Request.Path}");
});
</pre><p><br></p><ol><li><p><code><strong>app.UseRouting();</strong></code><strong>:</strong> This line activates routing middleware. It sets up the machinery to analyze incoming requests and match them against your defined endpoints.</p></li><li><p><code><strong>app.UseEndpoints(endpoints =&gt; { ... });</strong></code><strong>:</strong> This lambda expression configures the endpoints of your application:</p><ul><li><p><code>endpoints.MapGet("map1", ...);</code>: Registers a GET endpoint that responds to the path "/map1" with the text "In Map 1".</p></li><li><p><code>endpoints.MapPost("map2", ...);</code>: Registers a POST endpoint for the path "/map2", responding with "In Map 2".</p></li></ul></li><li><p><code><strong>app.Run(async context =&gt; { ... });</strong></code><strong>:</strong> This is a fallback terminal middleware. If no other endpoint matches the request (e.g., if you visit "/map3"), it will execute this code, writing the requested path to the response.</p></li></ol><p><br></p><p><br></p><h4>GetEndpoint()</h4><p>In ASP.NET Core, the <code>GetEndpoint()</code> method is a powerful tool for retrieving information about the specific endpoint that was selected to handle an incoming HTTP request. This method is an extension method available on the <code>HttpContext</code> object.</p><ul><li><p><strong>Purpose:</strong> It allows you to access details about the matched endpoint, such as its display name, route pattern, metadata, and more.</p></li><li><p><strong>When to Use It:</strong> You typically use <code>GetEndpoint()</code> within middleware components to make decisions based on the selected endpoint or to extract information that's relevant to your custom logic.</p></li><li><p><strong>Middleware Placement:</strong> The <code>GetEndpoint()</code> method will return a valid <code>Endpoint</code> object <strong>only after</strong> the <code>UseRouting</code> middleware has executed and successfully matched the request to an endpoint.</p></li></ul><p><br></p><p>Code:</p><pre class="prettyprint linenums">var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// Middleware 1: Before Routing
app.Use(async (context, next) =&gt; 
{
    Microsoft.AspNetCore.Http.Endpoint? endPoint = context.GetEndpoint();
    if (endPoint != null)
    {
        await context.Response.WriteAsync($"Endpoint: {endPoint.DisplayName}\n");
    }
    await next(context);
});

// Enable Routing Middleware
app.UseRouting();

// Middleware 2: After Routing
app.Use(async (context, next) =&gt;
{
    Microsoft.AspNetCore.Http.Endpoint? endPoint = context.GetEndpoint();
    if (endPoint != null)
    {
        await context.Response.WriteAsync($"Endpoint: {endPoint.DisplayName}\n");
    }
    await next(context);
});

// Creating Endpoints
app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapGet("map1", async (context) =&gt; 
    {
        await context.Response.WriteAsync("In Map 1");
    });

    endpoints.MapPost("map2", async (context) =&gt;
    {
        await context.Response.WriteAsync("In Map 2");
    });
});

// Fallback Middleware
app.Run(async context =&gt; 
{
    await context.Response.WriteAsync($"Request received at {context.Request.Path}");
});

app.Run();</pre><p><br></p><p>Let's analyze the code step-by-step:</p><ol><li><p><strong>Middleware 1 (Before Routing):</strong></p><ul><li><p>Here, <code>GetEndpoint()</code> will return <code>null</code> because routing hasn't happened yet. The request hasn't been matched to any specific endpoint.</p></li></ul></li><li><p><code><strong>app.UseRouting();</strong></code></p><ul><li><p>This enables the routing middleware, which is responsible for matching the request to an endpoint.</p></li></ul></li><li><p><strong>Middleware 2 (After Routing):</strong></p><ul><li><p>Now, <code>GetEndpoint()</code> will return the matched endpoint object (if a match was found). You can access its <code>DisplayName</code> (or other properties) to get information about the selected endpoint.</p></li></ul></li></ol><ul><li><p>For a GET request to "/map1", the display name would be "map1".</p></li><li><p>For a POST request to "/map2", the display name would be "map2".</p></li><li><p>For any other path, the display name would be null (since the fallback middleware handles those cases).</p></li></ul><ol start="4"><li><p><strong>Endpoint Creation:</strong></p><ul><li><p>The <code>app.UseEndpoints</code> section defines your endpoints (routes).</p></li></ul></li><li><p><strong>Fallback Middleware:</strong></p><ul><li><p>This middleware handles requests that didn't match any defined endpoints. It simply writes the requested path to the response.</p></li></ul></li></ol><p><br></p><p><br></p><p><br></p><h4>Route Parameters</h4><p>Route parameters are placeholders within your URL patterns that capture values from incoming requests. These values can then be used within your endpoint handlers to customize the response or perform specific actions.</p><p><strong>Types of Route Parameters</strong></p><ol><li><p><strong>Required Parameters:</strong></p><ul><li><p><strong>Syntax:</strong> Enclosed in curly braces <code>{}</code>.</p></li><li><p><strong>Behavior:</strong> Must be provided in the URL for the route to match. If not present, the request won't match this endpoint.</p></li><li><p><strong>Example:</strong> <code>/products/{id}</code> (The <code>id</code> parameter is required).</p></li></ul></li><li><p><strong>Optional Parameters:</strong></p><ul><li><p><strong>Syntax:</strong> Enclosed in curly braces <code>{}</code> and followed by a question mark <code>?</code>.</p></li><li><p><strong>Behavior:</strong> Can be omitted from the URL. If not present, the parameter's value will be <code>null</code>.</p></li><li><p><strong>Example:</strong> <code>/products/details/{id?}</code> (The <code>id</code> parameter is optional).</p></li></ul></li><li><p><strong>Parameters with Default Values:</strong></p><ul><li><p><strong>Syntax:</strong> Enclosed in curly braces <code>{}</code>, followed by an equals sign <code>=</code>, and then the default value.</p></li><li><p><strong>Behavior:</strong> If not provided in the URL, the parameter will take the specified default value.</p></li><li><p><strong>Example:</strong> <code>/employee/profile/{EmployeeName=harsha}</code> (The <code>EmployeeName</code> parameter defaults to "harsha").</p></li></ul></li></ol><p>Code:</p><pre class="prettyprint linenums">// ... (UseRouting and other middleware) ...

app.UseEndpoints(endpoints =&gt;
{
    // Required Parameters
    endpoints.Map("files/{filename}.{extension}", async context =&gt;
    {
        string? fileName = Convert.ToString(context.Request.RouteValues["filename"]);
        string? extension = Convert.ToString(context.Request.RouteValues["extension"]);

        await context.Response.WriteAsync($"In files - {fileName} - {extension}");
    });

    // Default Parameter
    endpoints.Map("employee/profile/{EmployeeName=harsha}", async context =&gt;
    {
        string? employeeName = Convert.ToString(context.Request.RouteValues["employeename"]);
        await context.Response.WriteAsync($"In Employee profile - {employeeName}");
    });

    // Optional Parameter
    endpoints.Map("products/details/{id?}", async context =&gt; {
        if (context.Request.RouteValues.ContainsKey("id"))
        {
            int id = Convert.ToInt32(context.Request.RouteValues["id"]);
            await context.Response.WriteAsync($"Products details - {id}");
        }
        else
        {
            await context.Response.WriteAsync($"Products details - id is not supplied");
        }
    });
});

// ... (Fallback middleware) ...
</pre><p><br></p><ol><li><p><strong>Required Parameters Example:</strong></p><ul><li><p>The route <code>files/{filename}.{extension}</code> expects both <code>filename</code> and <code>extension</code> to be present in the URL (e.g., <code>/files/sample.txt</code>).</p></li><li><p>The endpoint handler extracts these values from <code>context.Request.RouteValues</code> and uses them in the response.</p></li></ul></li><li><p><strong>Default Parameter Example:</strong></p><ul><li><p>The route <code>employee/profile/{EmployeeName=harsha}</code> has a default value for <code>EmployeeName</code>.</p></li><li><p>If you visit <code>/employee/profile</code>, the response will be "In Employee profile - harsha".</p></li><li><p>If you visit <code>/employee/profile/john</code>, the response will be "In Employee profile - john".</p></li></ul></li><li><p><strong>Optional Parameter Example:</strong></p><ul><li><p>The route <code>products/details/{id?}</code> allows the <code>id</code> parameter to be omitted.</p></li><li><p>If you visit <code>/products/details/123</code>, it will show the product details for ID 123.</p></li><li><p>If you visit <code>/products/details</code>, it will indicate that the ID was not provided.</p></li></ul></li></ol><p><br></p><p><br></p><p><br></p><h4>Route Constraints</h4><p>Route constraints are an essential tool in ASP.NET Core routing that allows you to add extra validation to your route parameters. They define rules that restrict the values a parameter can accept, helping you filter out invalid requests before they reach your endpoint handlers.</p><p><strong>Why Use Route Constraints?</strong></p><ul><li><p><strong>Enhanced Validation:</strong> Ensure that only requests with valid parameter values are handled.</p></li><li><p><strong>Improved Security:</strong> Prevent malicious input by rejecting requests with potentially harmful values.</p></li><li><p><strong>Cleaner Code:</strong> Avoid cluttering your endpoint handlers with validation logic.</p></li><li><p><strong>Explicit Routing:</strong> Make your routes more self-documenting and easier to understand.</p></li></ul><p><br></p><p><br></p><h4>Common Route Constraints</h4><p>ASP.NET Core provides a variety of built-in route constraints:</p><ul><li><p><code><strong>int</strong></code><strong>:</strong> Requires the parameter value to be an integer.</p></li><li><p><code><strong>bool</strong></code><strong>:</strong> Requires the parameter value to be a boolean (<code>true</code> or <code>false</code>).</p></li><li><p><code><strong>datetime</strong></code><strong>:</strong> Requires the parameter value to be a valid date and time string.</p></li><li><p><code><strong>decimal</strong></code><strong>, </strong><code><strong>double</strong></code><strong>, </strong><code><strong>float</strong></code><strong>, </strong><code><strong>long</strong></code><strong>:</strong> Require the parameter value to be of the specified numeric type.</p></li><li><p><code><strong>guid</strong></code><strong>:</strong> Requires the parameter value to be a valid GUID (Globally Unique Identifier).</p></li><li><p><code><strong>alpha</strong></code><strong>:</strong> Requires the parameter value to consist only of alphabetic characters (a-z, A-Z).</p></li><li><p><code><strong>regex</strong></code><strong>:</strong> Requires the parameter value to match a regular expression pattern.</p></li><li><p><code><strong>length</strong></code><strong>:</strong> Requires the parameter value to have a specific length or within a specified range.</p></li><li><p><code><strong>min</strong></code><strong>, </strong><code><strong>max</strong></code><strong>, </strong><code><strong>range</strong></code><strong>:</strong> Require the parameter value to be greater than or equal to the minimum (<code>min</code>), less than or equal to the maximum (<code>max</code>), or within a specific range (<code>range</code>).</p></li></ul><p>Code</p><pre class="prettyprint linenums">// ... (UseRouting and other middleware) ...

app.UseEndpoints(endpoints =&gt;
{
    // ... (other endpoints) ...

    // Alphabetic and Length Constraint
    endpoints.Map("employee/profile/{EmployeeName:length(4,7):alpha=harsha}", async context =&gt;
    {
        // ...
    });


    // Integer, Range, and Optional Constraint
    endpoints.Map("products/details/{id:int:range(1,1000)?}", async context =&gt; {
        // ...
    });

    // DateTime Constraint
    endpoints.Map("daily-digest-report/{reportdate:datetime}", async context =&gt;
    {
        // ...
    });

    // GUID Constraint
    endpoints.Map("cities/{cityid:guid}", async context =&gt;
    {
        // ...
    });

    // Int, Min, Regex Constraint
    endpoints.Map("sales-report/{year:int:min(1900)}/{month:regex(^(apr|jul|oct|jan)$)}", async context =&gt;
    {
        // ...
    });
});

// ... (Fallback middleware) ...</pre><p><br></p><ol><li><p><strong>Alphabetic and Length Constraint:</strong> <code>/employee/profile/{EmployeeName:length(4,7):alpha=harsha}</code>: Ensures <code>EmployeeName</code> is 4-7 characters long and consists only of alphabetic characters. If not supplied, it defaults to "harsha".</p></li><li><p><strong>Integer, Range, and Optional Constraint:</strong> <code>/products/details/{id:int:range(1,1000)?}</code>: Requires <code>id</code> to be an integer between 1 and 1000. The question mark makes it optional.</p></li><li><p><strong>DateTime Constraint:</strong> <code>/daily-digest-report/{reportdate:datetime}</code>: Requires <code>reportdate</code> to be a valid date-time string.</p></li><li><p><strong>GUID Constraint:</strong> <code>/cities/{cityid:guid}</code>: Requires <code>cityid</code> to be a valid GUID.</p></li><li><p><strong>Integer, Min, and Regex Constraint:</strong> <code>/sales-report/{year:int:min(1900)}/{month:regex(^(apr|jul|oct|jan)$)}</code>: Requires <code>year</code> to be an integer greater than or equal to 1900, and <code>month</code> to be one of the specified values (apr, jul, oct, jan).</p></li></ol><p><br></p><p><br></p><p><br></p><h4>Custom Route Constraint Classes</h4><p>While ASP.NET Core offers a variety of built-in route constraints, sometimes your application requires more specialized validation rules. Custom route constraint classes allow you to define your own criteria for determining whether a parameter value is valid.</p><p><strong>Key Requirements</strong></p><ol><li><p><strong>Implement </strong><code><strong>IRouteConstraint</strong></code><strong>:</strong> Create a class that implements the <code>IRouteConstraint</code> interface.</p></li><li><p><code><strong>Match</strong></code><strong> Method:</strong> Implement the <code>Match</code> method, which will contain your custom validation logic. This method receives several parameters:</p><ul><li><p><code>httpContext</code>: The current <code>HttpContext</code>.</p></li><li><p><code>route</code>: The <code>IRouter</code> object associated with the route.</p></li><li><p><code>routeKey</code>: The name of the route parameter being validated.</p></li><li><p><code>values</code>: A dictionary containing the route values.</p></li><li><p><code>routeDirection</code>: Indicates whether the route is being matched for an incoming request or for generating a URL.</p></li></ul></li><li><p><strong>Return </strong><code><strong>true</strong></code><strong> or </strong><code><strong>false</strong></code><strong>:</strong> The <code>Match</code> method must return <code>true</code> if the parameter value is valid according to your constraint, and <code>false</code> otherwise.</p></li></ol><p><br></p><p>Code</p><pre class="prettyprint linenums">// MonthsCustomConstraint.cs
public class MonthsCustomConstraint : IRouteConstraint
{
    public bool Match(HttpContext? httpContext, IRouter? route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection)
    {
        // Check if the parameter value exists
        if (!values.ContainsKey(routeKey))
        {
            return false; // Not a match
        }

        Regex regex = new Regex("^(apr|jul|oct|jan)$");
        string? monthValue = Convert.ToString(values[routeKey]);

        if (regex.IsMatch(monthValue))
        {
            return true; // It's a match
        }
        return false; // Not a match
    }
}</pre><p><br></p><p>Let's break this down:</p><ol><li><p><strong>Implementation of </strong><code><strong>IRouteConstraint</strong></code><strong>:</strong> The <code>MonthsCustomConstraint</code> class clearly implements this interface, signaling that it's a custom route constraint.</p></li><li><p><code><strong>Match</strong></code><strong> Method:</strong></p><ul><li><p>It first checks if the <code>values</code> dictionary contains the route parameter being validated (<code>routeKey</code>). If not, it's an immediate mismatch, and <code>false</code> is returned.</p></li><li><p>A regular expression (<code>^(apr|jul|oct|jan)$</code>) is used to define the valid month values.</p></li><li><p>The value associated with the <code>routeKey</code> is retrieved from the <code>values</code> dictionary and converted to a string.</p></li><li><p>The <code>Regex.IsMatch</code> method tests whether the retrieved value matches the allowed month pattern.</p></li><li><p>Returns <code>true</code> if the value matches, and <code>false</code> otherwise.</p></li></ul></li></ol><p><br></p><p><strong>Using the Custom Constraint</strong></p><pre class="prettyprint linenums">// ... (in your endpoint configuration) ...
endpoints.Map("sales-report/{year:int:min(1900)}/{month:months}", async context =&gt;
{
    // ... your endpoint handler logic ...
});
</pre><p><br></p><ul><li><p>Notice the <code>:months</code> constraint after the <code>month</code> parameter. This indicates that the value for <code>month</code> should be validated against the <code>MonthsCustomConstraint</code> class.</p></li></ul><p><br></p><p><br></p><p><br></p><h4>Endpoint Selection</h4><p>When a request arrives at your ASP.NET Core application, the routing middleware (<code>UseRouting</code>) analyzes the URL and HTTP method. It then compares this information against the collection of endpoints you've defined using methods like <code>MapGet</code>, <code>MapPost</code>, etc. The goal is to find the most suitable endpoint to handle the request.</p><p>However, what happens when multiple endpoints seem like potential matches? ASP.NET Core employs a well-defined algorithm to determine the winning endpoint.</p><p><strong>Endpoint Selection Algorithm</strong></p><ol><li><p><strong>Precedence:</strong></p><ul><li><p><strong>Explicit Matches:</strong> Endpoints defined with more specific patterns (e.g., <code>/products/{id}</code>) take precedence over those with broader patterns (e.g., <code>/products</code>).</p></li><li><p><strong>Order of Registration:</strong> If multiple endpoints with equally specific patterns could match, the endpoint that was registered <em>first</em> wins.</p></li></ul></li><li><p><strong>HTTP Method:</strong></p><ul><li><p><strong>Exact Match:</strong> If the request method (GET, POST, etc.) exactly matches the method specified for an endpoint, that endpoint is preferred.</p></li></ul></li><li><p><strong>Route Constraints:</strong></p><ul><li><p><strong>More Specific Constraints:</strong> Endpoints with more restrictive route constraints (e.g., <code>id:int:range(1,100)</code> vs. <code>id:int</code>) are favored.</p></li></ul></li><li><p><strong>Catch-All (Fallback):</strong></p><ul><li><p>If no other endpoint matches, and you have a catch-all endpoint (defined using <code>MapFallback</code>), it will be selected.</p></li></ul></li></ol><p><br></p><p><strong>Order of Precedence: A Visual Summary</strong></p><ol><li><p>Explicit Match with Exact HTTP Method and More Specific Route Constraints</p></li><li><p>Explicit Match with Exact HTTP Method and Less Specific Route Constraints</p></li><li><p>Explicit Match with Any HTTP Method and More Specific Route Constraints</p></li><li><p>Explicit Match with Any HTTP Method and Less Specific Route Constraints</p></li><li><p>Order of Registration (if specificity is equal)</p></li><li><p>Catch-All Endpoint (if no other match is found)</p></li></ol><p><br></p><p><strong>Practical Implications and Tips</strong></p><ul><li><p><strong>Mind Your Order:</strong> Be mindful of the order in which you register your endpoints, especially if they have similar patterns.</p></li><li><p><strong>Specificity Wins:</strong> Define your routes as specifically as possible to avoid ambiguity.</p></li><li><p><strong>Route Constraints:</strong> Use route constraints to narrow down the valid values for parameters.</p></li><li><p><strong>Catch-All with Caution:</strong> Catch-all endpoints can be useful, but use them sparingly to avoid unintended matches.</p></li><li><p><strong>Endpoint Metadata:</strong> Explore the <code>Endpoint</code> object's metadata for insights into why a particular endpoint was selected.</p></li></ul><p>Code</p><pre class="prettyprint linenums">app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapGet("/products/{id:int}", GetProductById); // Most specific
    endpoints.MapGet("/products", GetAllProducts);         // Less specific
    endpoints.MapGet("/{path?}", CatchAllHandler);          // Catch-all
});
</pre><p><br></p><p>In this example:</p><ul><li><p><code>/products/123</code> will match the first endpoint (<code>GetProductById</code>).</p></li><li><p><code>/products</code> will match the second endpoint (<code>GetAllProducts</code>).</p></li><li><p><code>/anything-else</code> will match the catch-all endpoint (<code>CatchAllHandler</code>).</p></li></ul><p><br></p><p><strong>Resolving Ambiguity</strong></p><p>If the routing system cannot definitively determine the best match, you'll encounter an <code>AmbiguousMatchException</code>. This exception signals that you need to refine your route definitions or registration order to eliminate the conflict.</p><p><br></p><p><br></p><p><br></p><h4>Static Files in ASP.NET Core</h4><p>Static files are the assets that make up the visual presentation and functionality of your web application:</p><ul><li><p><strong>HTML Files:</strong> The structure of your web pages.</p></li><li><p><strong>CSS Stylesheets:</strong> The styling and appearance of your content.</p></li><li><p><strong>JavaScript Files:</strong> The interactive elements and logic of your application.</p></li><li><p><strong>Images:</strong> Visual elements that enhance the user experience.</p></li></ul><p>ASP.NET Core provides the <code>UseStaticFiles()</code> middleware component to efficiently serve these static files directly to the browser without requiring any server-side processing.</p><p><br></p><p><code><strong>WebRoot</strong></code><strong>: The Default Location</strong></p><p>The <code>WebRoot</code> property in ASP.NET Core specifies the default directory from which static files are served. By default, this directory is named "wwwroot" and is located at the root of your project. However, you can customize this location if needed.</p><p><br></p><p><code><strong>UseStaticFiles()</strong></code><strong> Middleware: Enabling Static File Serving</strong></p><ul><li><p><strong>Basic Usage:</strong> Calling <code>app.UseStaticFiles();</code> with no arguments will serve static files from the default <code>WebRoot</code> directory.</p></li><li><p><strong>Customization:</strong> You can customize the behavior of <code>UseStaticFiles()</code> by passing a <code>StaticFileOptions</code> object:</p><ul><li><p><code>FileProvider</code>: Specify a different file provider (e.g., <code>PhysicalFileProvider</code>) to serve files from a custom location.</p></li><li><p><code>RequestPath</code>: Configure the base URL path for your static files (e.g., <code>/static</code>).</p></li><li><p><code>ContentTypeProvider</code>: Customize how content types are determined for different file extensions.</p></li><li><p><code>OnPrepareResponse</code>: Perform additional actions on the response before it's sent to the client.</p></li></ul></li></ul><p><br></p><p>Code</p><pre class="prettyprint linenums">using Microsoft.Extensions.FileProviders;

// ...

var builder = WebApplication.CreateBuilder(new WebApplicationOptions() 
{
    WebRootPath = "myroot" 
});
var app = builder.Build();

// Serve from the specified WebRoot ("myroot" in this case)
app.UseStaticFiles(); 

// Serve from a custom directory ("mywebroot") located within the project's ContentRootPath
app.UseStaticFiles(new StaticFileOptions()
{
    FileProvider = new PhysicalFileProvider(
        Path.Combine(builder.Environment.ContentRootPath, "mywebroot")
    )
}); 
// ... (rest of your middleware and endpoints) ...</pre><p><br></p><p><strong>Explanation</strong></p><ol><li><p><strong>Custom </strong><code><strong>WebRoot</strong></code><strong>:</strong> The <code>WebRootPath</code> property in <code>WebApplicationOptions</code> is set to "myroot", making "myroot" the default location for static files served by the first <code>app.UseStaticFiles()</code>.</p></li><li><p><strong>Default Static Files:</strong> The initial <code>app.UseStaticFiles();</code> call serves files directly from the "myroot" directory. For instance, a request to <code>/styles.css</code> would look for a file named <code>styles.css</code> within "myroot".</p></li><li><p><strong>Custom Static Files Location:</strong> The second <code>app.UseStaticFiles</code> call configures a <code>PhysicalFileProvider</code> to serve files from a custom location: "mywebroot". This directory is located within the application's <code>ContentRootPath</code> (the project's root folder).</p></li></ol><p><br></p><p><strong>Important Considerations</strong></p><ul><li><p><strong>Security:</strong> Always be cautious about the files you expose as static content. Avoid placing sensitive information in your <code>WebRoot</code> or custom directories.</p></li><li><p><strong>Performance:</strong> Consider using caching and compression techniques to optimize the delivery of static files.</p></li><li><p><strong>Content Security Policy (CSP):</strong> Implement a CSP to mitigate cross-site scripting (XSS) attacks that could exploit your static files.</p></li></ul><p>By effectively managing your static files and utilizing the <code>UseStaticFiles()</code> middleware, you can enhance your ASP.NET Core application's performance and user experience.</p><p><br></p><p><br></p><p><br></p><p><br></p><h4>KeyPoints to remember:</h4><p><strong>Routing</strong></p><ul><li><p><strong>Purpose:</strong> Matches incoming HTTP requests to specific endpoints (controllers, Razor Pages, minimal APIs) in your application.</p></li><li><p><strong>Middleware:</strong> <code>UseRouting</code> and <code>UseEndpoints</code> are essential middleware components for routing.</p><ul><li><p><code>UseRouting</code>: Analyzes the request URL and matches it to an endpoint.</p></li><li><p><code>UseEndpoints</code>: Executes the matched endpoint's code.</p></li></ul></li><li><p><code><strong>Map*</strong></code><strong> Methods:</strong> Used to define endpoints for different HTTP methods (e.g., <code>MapGet</code>, <code>MapPost</code>, <code>MapControllerRoute</code>).</p></li></ul><p><br></p><p><strong>Endpoint Selection Order</strong></p><ul><li><p><strong>Specificity:</strong> More specific routes (with more parameters or constraints) take precedence over less specific ones.</p></li><li><p><strong>Registration Order:</strong> If multiple routes are equally specific, the one registered first wins.</p></li><li><p><strong>HTTP Method:</strong> Routes with an exact method match are preferred.</p></li><li><p><strong>Route Constraints:</strong> Routes with more restrictive constraints are favored.</p></li><li><p><strong>Catch-All:</strong> A fallback endpoint handles unmatched requests.</p></li></ul><p><br></p><p><strong>Route Parameters</strong></p><ul><li><p><strong>Types:</strong> Required (<code>{id}</code>), optional (<code>{id?}</code>), default value (<code>{id=123}</code>).</p></li><li><p><strong>Access:</strong> Parameter values are accessed through <code>context.Request.RouteValues</code>.</p></li></ul><p><br></p><p><strong>Route Constraints</strong></p><ul><li><p><strong>Purpose:</strong> Restrict the allowed values for route parameters.</p></li><li><p><strong>Built-in:</strong> <code>int</code>, <code>bool</code>, <code>datetime</code>, <code>guid</code>, <code>regex</code>, <code>length</code>, <code>min</code>, <code>max</code>, <code>range</code>, etc.</p></li><li><p><strong>Custom:</strong> Create classes implementing <code>IRouteConstraint</code> to define your own validation logic.</p></li></ul><p><code><strong>GetEndpoint()</strong></code></p><ul><li><p><strong>Purpose:</strong> Retrieves information about the matched endpoint.</p></li><li><p><strong>Usage:</strong> Call <code>context.GetEndpoint()</code> within middleware <strong>after</strong> <code>UseRouting</code>.</p></li><li><p><strong>Information:</strong> Access endpoint properties like <code>DisplayName</code>, route pattern, and metadata.</p></li></ul><p><br></p><p><strong>Static Files</strong></p><ul><li><p><code><strong>WebRoot</strong></code><strong>:</strong> The default directory from which static files are served (usually "wwwroot").</p></li><li><p><code><strong>UseStaticFiles()</strong></code><strong>:</strong> Middleware for serving static files (HTML, CSS, JavaScript, images).</p></li><li><p><strong>Customization:</strong> Use <code>StaticFileOptions</code> to change the file provider, request path, or other settings.</p></li></ul><p><br></p><p><strong>Key Interview Tips</strong></p><ul><li><p><strong>Explain the Flow:</strong> Clearly articulate how a request flows through the routing middleware and how endpoints are selected.</p></li><li><p><strong>Code Examples:</strong> Be prepared to write code snippets demonstrating endpoint registration, parameter usage, and constraint application.</p></li><li><p><strong>Troubleshooting:</strong> Explain how you would diagnose and fix common routing issues (e.g., 404 errors, ambiguous matches).</p></li><li><p><strong>Best Practices:</strong> Discuss how to design clean, maintainable, and secure routes.</p></li></ul><p><br></p><p><br></p></div>
            </div>
        </div>
    </body>
</html>
